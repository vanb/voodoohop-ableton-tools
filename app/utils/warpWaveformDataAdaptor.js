// "use strict";

/**
 * ArrayBuffer adapter consumes binary waveform data (data format version 1).
 * It is used as a data abstraction layer by `WaveformData`.
 *
 * This is supposed to be the fastest adapter ever:
 * * **Pros**: working directly in memory, everything is done by reference (including the offsetting)
 * * **Cons**: binary data are hardly readable without data format knowledge (and this is why this adapter exists).
 *
 * Also, it is recommended to use the `fromResponseData` factory.
 *
 * @see WarpWaveformDataAdaptor.fromResponseData
 * @param {DataView} response_data
 * @constructor
 * 
 */

var binarySearch = require("binary-search");


var WarpWaveformDataAdaptor = function WarpWaveformDataAdaptor(sourceAdaptor, warpMarkers) {
  console.log("initialized warping adaptor", sourceAdaptor, warpMarkers)
  this.sourceAdapter = sourceAdaptor;
  this.warpMarkers = warpMarkers;
};




export default function getCreator(SourceAdaptor, warpMarkers) {
  return {
    fromResponseData: (buffer) => {
      console.log("creating sourceadaptor from buffer",buffer);
      var sourceAdaptor = SourceAdaptor.fromResponseData(buffer);
      console.log("creating new warpWaveformDataAdaptor");
      return new WarpWaveformDataAdaptor(sourceAdaptor, warpMarkers);
    },
    isCompatible: () => true
  }
}


// WarpWaveformDataAdaptor.fromResponseData = function fromArrayBufferResponseData(response_data){
//   return new WarpWaveformDataAdaptor(new DataView(response_data));
// };


/**
 * Detects if a set of data is suitable for the ArrayBuffer adapter.
 * It is used internally by `WaveformData.create` so you should not bother using it.
 *
 * @static
 * @param {Mixed} data
 * @returns {boolean}
 */
// WarpWaveformDataAdaptor.isCompatible = function isCompatible(data){
//   return this.sourceAdapter.isCompatible(data);//data && typeof data === "object" && "byteLength" in data;
// };

/**
 * Setup factory to create an adapter based on heterogeneous input formats.
 *
 * It is the preferred way to build an adapter instance.
 *
 * ```javascript
 * var arrayBufferAdapter = WaveformData.adapters.arraybuffer;
 * var xhr = new XMLHttpRequest();
 *
 * // .dat file generated by audiowaveform program
 * xhr.open("GET", "http://example.com/waveforms/track.dat");
 * xhr.responseType = "arraybuffer";
 * xhr.addEventListener("load", function onResponse(progressEvent){
 *  var responseData = progressEvent.target.response;
 *
 *  // doing stuff with the raw data ...
 *  // you only have access to WarpWaveformDataAdaptor API
 *  var adapter = arrayBufferAdapter.fromResponseData(responseData);
 *
 *  // or making things easy by using WaveformData ...
 *  // you have access WaveformData API
 *  var waveform = new WaveformData(responseData, arrayBufferAdapter);
 * });
 *
 * xhr.send();
 * ```

 * @static
 * @param {ArrayBuffer} response_data
 * @return {WarpWaveformDataAdaptor}
 */

/**
 * @namespace WarpWaveformDataAdaptor
 */
WarpWaveformDataAdaptor.prototype = {
  /**
   * Returns the data format version number.
   *
   * @return {Integer} Version number of the consumed data format.
   */
  get version(){
    return this.sourceAdapter.version;
  },
  /**
   * Indicates if the response body is encoded in 8bits.
   *
   * **Notice**: currently the adapter only deals with 8bits encoded data.
   * You should favor that too because of the smaller data network fingerprint.
   *
   * @return {boolean} True if data are declared to be 8bits encoded.
   */
  get is_8_bit(){
    return  this.sourceAdapter.is_8_bit;
  },
  /**
   * Indicates if the response body is encoded in 16bits.
   *
   * @return {boolean} True if data are declared to be 16bits encoded.
   */
  get is_16_bit(){
    return this.sourceAdapter.is_16_bit;
  },
  /**
   * Returns the number of samples per second.
   *
   * @return {Integer} Number of samples per second.
   */
  get sample_rate(){
    return this.sourceAdapter.sample_rate;// * this.warpMarkers.get("warpMarkers").last().get("desttimesam;
  },
  /**
   * Returns the scale (number of samples per pixel).
   *
   * @return {Integer} Number of samples per pixel.
   */
  get scale(){
    return this.sourceAdapter.scale;	
  },
  /**
   * Returns the length of the waveform data (number of data points).
   *
   * @return {Integer} Length of the waveform data.
   */
  get length(){
    console.log("lengththis",this.sourceAdapter.length);
    return this.sourceAdapter.length;
  },
  /**
   * Returns a value at a specific offset.
   *
   * @param {Integer} index
   * @return {number} waveform value
   */
  at: function at_sample(index){
   
    var time = (Math.floor(index/2)/this.sample_rate) * this.scale*1000;
    console.log("interpolatiiing",index,time);
    // return this.sourceAdapter.at(index);
    var markersArr = this.warpMarkers.get("warpMarkers").toArray();
    var searchArr = markersArr.map(m => m.get('sourcetime'));
    console.log("searching",markersArr[markersArr.length-1],"for time",time);
    var resultIndex = (binarySearch(searchArr,time,  (a, b) => a-b
      // return warpedTime > time ? -1 : (warpedTime < time ? 1 :0);
    )+1)*-1;
    var pm = markersArr[resultIndex-1];
    var nm = markersArr[resultIndex] || pm;
    pm = pm || nm;
    console.log("found",nm&&nm.toJS(),pm&&pm.toJS(),time);
    var interpolatedTime;
    if (!pm) {
      interpolatedTime =0;
    } else {
    if (nm == pm)
      interpolatedTime = nm.get("desttime");
    else {
      interpolatedTime = pm.get("desttime")+(time - pm.get("sourcetime"))/pm.get("playSpeed");
    }
    }
    var foundIndex=Math.floor((interpolatedTime)*this.sample_rate/this.scale/1000)*2+(index%2);
    console.log("found interpolated index:",resultIndex, markersArr.length,foundIndex, this.sourceAdapter.length);

    return this.sourceAdapter.at(Math.min(foundIndex,this.length*2-1))    ;
  }
};

